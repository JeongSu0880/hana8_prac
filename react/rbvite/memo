강사님이랑 나랑 다른 점
1. readmode editmode를 나는 컴포넌트 자체로 나눴고 강사님은 상태로 관리함. (isEditing)
2. dirty에 대한 상태도 관리
과제 중요 요구 사항 두 개를 상태로 둠.
3. edit과 add를 합쳐서 saveItem 함수를 사용
id가 있고, cart.find(item => item.id === id) 가 있어야 editmode
4. 클릭하면 edit 모드로 전환되는 것을 안보이는 button으로 설정해서 onClick을 받아서 처리


<li> 태그 전체를 (key가 있는) Item으로 빼면 안 좋음. 왜냐면 ul 안에서 li를 사용하는데
해당 컴포넌트를 ul안에서만 사용해야하는 것. (커플링이 생김)

주의 : 디스트럭처링 할 때 동일한 변수 이름? 속성 이름이 겹쳐서 쓰이면 가독성이 안좋다.


Activity -> Dom을 그대로 유지?

지금 강사님이 하신 방식은 18 이하 버전 (Activity가 없을 때)


checkDirty 구현 방법
if (nameRef.current && priceRef.current) // DOM이 있어야 비교를 하니까
return item.name !== nameRef.current.value || item.price !== Number(priceRef.current?.value)


헷갈리는 개념!
DOM 커밋 주기와 useRef 사용시 current 값, 그리고 Activity 사용시 


useEffect는 DOM이 그려지고 나서 호출
 
래액트는 그리기 위해
=saveItem 할 때 , item.name = name;
item.price = price 가 아니ㅇ며 ㅇ

1교시 첫번쩨 시간 11시 부터수없 다시 들어.

컴포넌트를 찢는 이유 -

